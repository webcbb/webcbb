<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Wesib: Web Components Building Blocks</title>
	<meta name="description" content="Documentation for Wesib: Web Components Building Blocks">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">Wesib: Web Components Building Blocks</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>Wesib: Web Components Building Blocks</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#wesib-web-components-building-blocks" id="wesib-web-components-building-blocks" style="color: inherit; text-decoration: none;">
					<h1>Wesib: Web Components Building Blocks</h1>
				</a>
				<p><a href="https://www.npmjs.com/package/@wesib/wesib"><img src="https://img.shields.io/npm/v/@wesib/wesib.svg?logo=npm" alt="NPM"></a>
					<a href="https://github.com/wesib/wesib/actions?query=workflow%3ABuild"><img src="https://github.com/wesib/wesib/workflows/Build/badge.svg" alt="Build Status"></a>
					<a href="https://codecov.io/gh/wesib/wesib"><img src="https://codecov.io/gh/wesib/wesib/branch/master/graph/badge.svg" alt="codecov"></a>
					<a href="https://github.com/wesib/wesib"><img src="https://img.shields.io/static/v1?logo=github&label=GitHub&message=project&color=informational" alt="GitHub Project"></a>
				<a href="https://wesib.github.io/wesib/"><img src="https://img.shields.io/static/v1?logo=typescript&label=API&message=docs&color=informational" alt="API Documentation"></a></p>
				<p><a href="https://github.com/wesib/wesib">Wesib</a> is a base for web components definition.</p>
				<p>It provides a way to define custom elements. But instead of extending <code>HTMLElement</code>, it supports arbitrary component
				classes, and defines custom elements for them programmatically.</p>
				<p>Wesib provides an IoC container, a component definition and lifecycle callbacks, and an infrastructure for opt-in
				features that can involve in component definition process and thus alter the resulting components in very flexible way.</p>
				<p>This package provides a core API.</p>
				<p>The <a href="https://github.com/wesib/generic">@wesib/generic</a> package provides generic web components and features.</p>
				<p>The examples can be found in <a href="https://github.com/wesib/examples">@wesib/examples</a>.  </p>
				<a href="#components" id="components" style="color: inherit; text-decoration: none;">
					<h2>Components</h2>
				</a>
				<p>Wesib allows defining custom element by decorating a component class with <code>@Component</code> decorator:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@wesib/wesib&#x27;</span>;

<span class="hljs-meta">@Component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>) <span class="hljs-comment">// Custom element name</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> </span>{
  <span class="hljs-comment">// ...component definition</span>
}</code></pre>
				<p>No need to extend <code>HTMLElement</code> or any other class. Instead, Wesib creates a custom element accordingly to its
				definition built either programmatically or using component decorators.</p>
				<p>To register custom component(s) call <code>bootstrapComponents()</code> function like this:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { bootstrapComponents } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@wesib/wesib&#x27;</span>;

bootstrapComponents(MyComponent);</code></pre>
				<p>After that the custom element can be used anywhere in the document:</p>
				<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span></code></pre>
				<p>The component instance created along with a custom element and bound to it. All the logic of custom element delegated
				to the bound component instance.</p>
				<a href="#element-attributes" id="element-attributes" style="color: inherit; text-decoration: none;">
					<h2>Element Attributes</h2>
				</a>
				<p>To define custom element attributes use <code>@Attribute</code> or <code>@AttributeChanged</code> component property decorators,
				or <code>@Attributes</code> component class decorator.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Attribute, AttributeChanged, Attributes, Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@wesib/wesib&#x27;</span>;

<span class="hljs-meta">@Component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>) <span class="hljs-comment">// Custom element name</span>
<span class="hljs-meta">@Attributes</span>(
  <span class="hljs-string">&#x27;attribute-one&#x27;</span>,
  <span class="hljs-string">&#x27;another-attribute&#x27;</span>,   
)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> </span>{

  <span class="hljs-meta">@Attribute</span>(<span class="hljs-string">&#x27;attribute-two&#x27;</span>) <span class="hljs-comment">// Attribute name. When omitted the property name is used</span>
  attribute2!: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// Attribute value is accessed instead.</span>

  <span class="hljs-meta">@AttributeChanged</span>(<span class="hljs-string">&#x27;attribute-three&#x27;</span>) <span class="hljs-comment">// Attribute name. When omitted the method name is used  </span>
  <span class="hljs-function"><span class="hljs-title">setAttribute3</span>(<span class="hljs-params">newValue: <span class="hljs-built_in">string</span>, oldValue: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>)</span> {
    <span class="hljs-comment">// This is called on attribute value modification with new and old values</span>
  }

}</code></pre>
				<pre><code class="language-HTML">&lt;my-component
  attribute-one=&quot;1&quot;  &lt;!-- Can be accessed with element&#x27;s `element.getAttribute(&quot;attribute-one&quot;)` --&gt;
  attribute-two=&quot;2&quot;  &lt;!-- Can be accessed as `attribute2` property of `MyComponent` --&gt;
  attribute-three&quot;3&quot; &lt;!-- Triggers `setAttribute3()` method call --&gt;
&gt;&lt;/my-component&gt;</code></pre>
				<a href="#element-properties" id="element-properties" style="color: inherit; text-decoration: none;">
					<h2>Element Properties</h2>
				</a>
				<p>To define the properties of custom element use a <code>@DomProperty</code> component property decorator.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { DomProperty, Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@wesib/wesib&#x27;</span>;

<span class="hljs-meta">@Component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>) <span class="hljs-comment">// Custom element name</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> </span>{

  <span class="hljs-meta">@DomProperty</span>(<span class="hljs-string">&#x27;elementProperty&#x27;</span>) <span class="hljs-comment">// Element property name. The decorated property name is used if omitted.</span>
  customProperty = <span class="hljs-number">12</span>; <span class="hljs-comment">// Element&#x27;s `elementProperty` is backed by this one.</span>

}</code></pre>
				<p>The same can be done for element methods with <code>@DomMethod</code> decorator, which is just a convenient alias for
				<code>@DomProperty</code>.</p>
				<a href="#ioc-container" id="ioc-container" style="color: inherit; text-decoration: none;">
					<h2>IoC Container</h2>
				</a>
				<p>Wesib provides contexts for each component and feature (see below). This context can be used to access provided values.</p>
				<p>For example, each component class constructor accepts a <code>ComponentContext</code> instance as its only argument.</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { ComponentContext, Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@wesib/wesib&#x27;</span>;

<span class="hljs-meta">@Component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>) <span class="hljs-comment">// Custom element name</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> </span>{

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> _service: MyService;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">context: ComponentContext</span>)</span> {
    <span class="hljs-built_in">this</span>._service = context.get(MyService); <span class="hljs-comment">// Obtain a `MyService` instance provided by some feature elsewhere.</span>
  }

}</code></pre>
				<p>IoC container implementation is based on <a href="https://npmjs.com/package/context-values">context-values</a>.</p>
				<a href="#features" id="features" style="color: inherit; text-decoration: none;">
					<h2>Features</h2>
				</a>
				<p>Apart from custom elements definition and IoC container, everything in Wesib is an opt-in feature.</p>
				<p>It is possible to define custom features to extend Wesib. E.g. to define or augment existing components, extend custom
				elements (like <code>@Attribute</code> or <code>@DomProperty</code> decorators do), or provide some context values.</p>
				<p>The feature is a class decorated with <code>@Feature</code> decorator:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> {
  ComponentContext,
  DefinitionContext,
  Feature,
  FeatureContext,
  FeatureSetup,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@wesib/wesib&#x27;</span>;

<span class="hljs-meta">@Feature</span>({
  <span class="hljs-attr">needs</span>: [
    OtherFeature1, <span class="hljs-comment">// Requires other features to be enabled.</span>
    MyComponent, <span class="hljs-comment">// The required component will be defined too.  </span>
  ],
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">setup: FeatureSetup</span>)</span> { 
    setup.provide({ 
      <span class="hljs-attr">a</span>: GlobalService,              <span class="hljs-comment">// Provide a `GlobalService` available globally</span>
      <span class="hljs-attr">as</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> GlobalService(), <span class="hljs-comment">// in all IoC contexts</span>
    }); 
    setup.perDefinition({
      <span class="hljs-attr">a</span>: DefinitionService,
      <span class="hljs-attr">by</span>: <span class="hljs-function">(<span class="hljs-params">definitionContext: DefinitionContext</span>) =&gt;</span> {
        <span class="hljs-comment">// Provide a `DefinitionService` available during component definition.</span>
        <span class="hljs-comment">// Such service will be provided per component class</span>
        <span class="hljs-comment">// and will be available during custom element construction,</span>
        <span class="hljs-comment">// e.g. to `onDefinition()` listeners.</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefinitionService(definitionContext);
      },
    });
    setup.perComponent({
      <span class="hljs-attr">a</span>: MyService,
      <span class="hljs-attr">by</span>: <span class="hljs-function">(<span class="hljs-params">componentContext: ComponentContext</span>) =&gt;</span> {
        <span class="hljs-comment">// Provide a `MyService` available to components.</span>
        <span class="hljs-comment">// Such service will be provided per component instance</span>
        <span class="hljs-comment">// and will be available to component instance and `onComponent()` listeners.</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyService(componentContext.component);
      },
    });
  },
  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">context: FeatureContext</span>)</span> {
    <span class="hljs-comment">// Bootstrap the feature by calling methods of provided context.</span>

    context.onDefinition(<span class="hljs-function">(<span class="hljs-params">definitionContext: DefinitionContext</span>) =&gt;</span> {
      <span class="hljs-comment">// Notified on each component definition.</span>

      <span class="hljs-comment">// The service provided with `perDefinition()` method above is available here      </span>
      <span class="hljs-keyword">const</span> definitionService = definitionContext.get(DefinitionService);

      definitionContext.whenReady(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// This is called when element class is defined.</span>
        <span class="hljs-built_in">console</span>.log(
          <span class="hljs-string">`Define element class <span class="hljs-subst">${definitionContext.elementType.name}</span>`</span>
          + <span class="hljs-string">` for component of <span class="hljs-subst">${definitionContext.componentType.name}</span> type`</span>)        
      });
    });
    context.onComponent(<span class="hljs-function">(<span class="hljs-params">componentContext: ComponentContext</span>) =&gt;</span> {
      <span class="hljs-comment">// Notified on each component instantiation.</span>

      <span class="hljs-comment">// The service provided with `perComponent()` method above is available here      </span>
      <span class="hljs-keyword">const</span> myService = componentContext.get(MyService);

      componentContext.whenReady(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// This is called when component is instantiated,</span>
        <span class="hljs-comment">// which happens right after custom element instantiation.</span>
        <span class="hljs-built_in">console</span>.log(componentContext.element, <span class="hljs-string">` is instantiated for`</span>, componentContext.component);
      });
    });
  }  
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFeature</span> </span>{} </code></pre>
				<p>To enable a custom feature just pass it to <code>bootstrapComponents()</code> like this:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { bootstrapComponents } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@wesib/wesib&#x27;</span>;

bootstrapComponents(MyFeature);</code></pre>
				<p>Note that components are kind of features that, when passed to this function (or enabled with <code>needs</code> option),
				register themselves as components.</p>
				<a href="#component-state" id="component-state" style="color: inherit; text-decoration: none;">
					<h2>Component State</h2>
				</a>
				<p>Whenever a component state changes, e.g. when element attribute or property value changes, a state update notification
				is issued.</p>
				<p>A state update notification can also be issued by calling a <code>ComponentContext.updateState()</code> method:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Component, ComponentContext } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@wesib/wesib&#x27;</span>;

<span class="hljs-meta">@Component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>) <span class="hljs-comment">// Custom element name</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> </span>{

  <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> _context: ComponentContext</span>)</span> {
  }

  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">loadData</span>(<span class="hljs-params"></span>)</span> {

    <span class="hljs-keyword">const</span> newData = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/data&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json());
    <span class="hljs-keyword">const</span> oldData = <span class="hljs-built_in">this</span>.data;

    <span class="hljs-built_in">this</span>.data = newData;
    <span class="hljs-built_in">this</span>._context.updateState(<span class="hljs-string">&#x27;data&#x27;</span>, newData, oldData); <span class="hljs-comment">// Update the state</span>
  }

}</code></pre>
				<p>A <code>ComponentState</code> instance available in component context allows to track the component state updates.</p>
				<a href="#shadow-dom" id="shadow-dom" style="color: inherit; text-decoration: none;">
					<h2>Shadow DOM</h2>
				</a>
				<p>It is possible to attach shadow root to custom element by decorating the component with <code>@AttachShadow</code> decorator.</p>
				<p>If shadow DOM is supported, then a shadow root will be attached to element. Otherwise, an element itself will be used
				as shadow root. In both cases the shadow root will be available in component context under <code>[ShadowContentRoot]</code> key.</p>
				<p>A <code>ComponentContext.contentRoot</code> property is always available. It either contains a shadow root, or element itself.
				This is a root DOM node component element contents.</p>
				<a href="#rendering" id="rendering" style="color: inherit; text-decoration: none;">
					<h2>Rendering</h2>
				</a>
				<p>Wesib core does not provide any mechanics for component rendering. It is completely up to the developer which rendering
				mechanics to use: direct DOM manipulations, template processing, virtual DOM, etc.</p>
				<p>However, Wesib is able to notify the renderer on component state updates and trigger its rendering. For that a <code>@Render</code>
				decorator can be applied to component renderer method:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { Attribute, Component, ComponentContext, Render } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@wesib/wesib&#x27;</span>;

<span class="hljs-meta">@Component</span>(<span class="hljs-string">&#x27;greet-text&#x27;</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetTextComponent</span> </span>{

  <span class="hljs-meta">@Attribute</span>()
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> _context: ComponentContext</span>)</span> {
  }

  <span class="hljs-meta">@Render</span>()
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>._context.contentRoot.innerText = <span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>!`</span>;
  }

}</code></pre>
				<p>The <code>@Render</code>-decorated method will be called from <code>requestAnimationFrame()</code> callback by default. So, it won&#39;t be
				called too frequently.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/@wesib_wesib.html">@wesib/wesib</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-namespace"><span class="tsd-kind-icon">Namespace</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
</body>
</html>